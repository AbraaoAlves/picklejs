{"version":3,"sources":["../lib/functions.js"],"names":["buildClassSelector","selectors","replace","selectElement","className","text","context","selector","el","get","cy","contains","Error","parseNumberEls","includes","ordinal","parsed","numbers","match","number","parseInt","getNormalized","elements","singular","Array","isArray","filter","firstOrdinal","lastParentSelectors","reduce","out","elementStr","i","element","pluralize","ELEMENT_SELECTORS","lastParent","default","join","last","eq","getSelector","itemShouldBeVisible","first","should","clickElement","parent","click","shouldExist","els","e","undefined","waitForResults","wait"],"mappings":"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","file":"functions.js","sourcesContent":["import {\n    ELEMENT_SELECTORS\n} from './variables';\n\nimport wordsToNumbers from 'words-to-numbers';\nimport pluralize from 'pluralize';\n\n// Builds class selectors for our react Styled Component classes (ie. accounts for the `-randomString`). You should just be able to type classes as usual\nexport const buildClassSelector = selectors => (\n    selectors.replace(/\\.([^.[:\\s]+)/g, '[class*=\"$1\"]')\n);\n\nexport const selectElement = (className, text, context) => {\n    const selector = buildClassSelector(className);\n    const el = context\n        ? context.get(selector)\n        : cy.get(selector);\n    \n    if (!text) return el;\n\n    if(el.contains(text)) {\n        return el;\n    } else {\n        throw new Error('Element doesn\\'t contain text');\n    }\n}\n\n// ex: Third Button => [ Button, 3 ]\nexport const parseNumberEls = el => {\n    if(el.includes('last')) {\n        return {\n            ordinal: 'last',\n            el: el.replace('last ', '')\n        }\n    } else {\n        const parsed = wordsToNumbers(el);\n        const numbers = parsed.match(/\\d+/);\n        \n        if(numbers) {\n            return {\n                el: parsed.replace(number[0] + ' ', ''),\n                ordinal: parseInt(number[0]),\n            };\n        } else {\n            return {\n                el: parsed,\n            };\n        }\n    }\n}\n\n// pass a single element or chain (parent => child) as an Array\n// to get the selected Cypress element\nexport const getNormalized = (elements, { text, singular } = {}) => {\n    if (!Array.isArray(elements)) {\n        elements = [elements];\n    }\n\n    // in case it comes in from a parent optional environemnt\n    elements = elements.filter(el=>el);\n\n    // for now we apply it to the first ordinal we get\n    // ex: third Button in the second Modal will just get the third Button overall\n    let firstOrdinal;\n    let lastParentSelectors;\n    \n    let className = elements.reduce((out, elementStr, i) => {\n        let element;\n        // ex: Button's => Button\n        element = elementStr.replace('\\'s', '');\n        \n        if(singular) {\n            // Buttons => Button\n            element = pluralize.singular(element);\n        }\n\n        const {\n            ordinal, \n            el\n        } = parseNumberEls(element);\n\n        if (!firstOrdinal && ordinal) {\n            firstOrdinal = ordinal;\n        }\n    \n        let selectors = ELEMENT_SELECTORS;\n\n        // for now just supports 1 level of nest\n        if (out[i - 1]) {            \n            selectors = lastParentSelectors;\n        }\n\n        const selector = selectors[el];\n\n        if (!selector) {\n            const lastParent = elements[i - 1]\n                ? elements[i - 1] + '>'\n                : '';\n            throw new Error(`The className was not defined for ${lastParent}${el}`);\n        }\n\n        if (selector.default) {\n            lastParentSelectors = selector;\n        }\n\n        // if it's a container\n        const className = selector.default\n            ? selector.default\n            : selector;\n    \n        return [...out, className];\n    }, []).join(' ');\n\n    if (text) {\n        className += `:contains(\"${text}\")`;\n    }\n\n    const el = selectElement(className);\n\n    if(firstOrdinal) {\n        if (firstOrdinal === 'last') {\n            return el.last();\n        } else {\n            return el.eq(firstOrdinal - 1);\n        }\n    }\n    \n    return el;\n}\n\nexport const getSelector = (el) => {\n    const selector = ELEMENT_SELECTORS[el];\n\n    if (!selector) {\n        throw Error(`getSelector cannot find class for ${el}`);\n    }\n\n    const className = selector.default\n            ? selector.default\n            : selector;\n    \n    return buildClassSelector(className);\n}\n\nexport const itemShouldBeVisible = el => (\n    getNormalized(el).first().should('exist')\n);\n\nexport const clickElement = (el, parent, text) => (\n    getNormalized([parent, el], { text })\n        .first()\n        .click()\n);\n\nexport const shouldExist = (element, { parent, text }) => {\n    const els = [parent, element].filter(e=>e)\n    const el = getNormalized(els);\n\n    return text !== undefined\n        ? el.contains(text)\n        : el.should('exist');\n}\n\nexport const waitForResults = () => {\n    cy.wait(1000);\n}"]}