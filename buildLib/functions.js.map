{"version":3,"sources":["../lib/functions.js"],"names":["buildClassSelector","selectors","replace","selectElement","className","text","context","selector","el","get","cy","contains","Error","parseNumberEls","ordinals","first","second","third","fourth","fifth","sixth","seventh","eighth","ninth","tenth","last","Object","entries","reduce","out","word","wordValue","ordinal","includes","getNormalized","elements","singular","Array","isArray","filter","firstOrdinal","lastParentSelectors","elementStr","i","element","pluralize","ELEMENT_SELECTORS","lastParent","default","join","eq","getSelector","itemShouldBeVisible","should","clickElement","parent","click","shouldExist","els","e","undefined","waitForResults","wait"],"mappings":"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","file":"functions.js","sourcesContent":["import {\n    ELEMENT_SELECTORS\n} from './variables';\n\nimport pluralize from 'pluralize';\n\n// Builds class selectors for our react Styled Component classes (ie. accounts for the `-randomString`). You should just be able to type classes as usual\nexport const buildClassSelector = selectors => (\n    selectors.replace(/\\.([^.[:\\s]+)/g, '[class*=\"$1\"]')\n);\n\nexport const selectElement = (className, text, context) => {\n    const selector = buildClassSelector(className);\n    const el = context\n        ? context.get(selector)\n        : cy.get(selector);\n    \n    if (!text) return el;\n\n    if(el.contains(text)) {\n        return el;\n    } else {\n        throw new Error('Element doesn\\'t contain text');\n    }\n}\n\n// ex: Third Button => [ Button, 3 ]\nexport const parseNumberEls = el => {\n    const ordinals = {\n        first: 1,\n        second: 2,\n        third: 3,\n        fourth: 4,\n        fifth: 5,\n        sixth: 6,\n        seventh: 7,\n        eighth: 8,\n        ninth: 9,\n        tenth: 10,\n        last: 'last',\n    };\n\n    return Object.entries(ordinals).reduce((out, [word, wordValue]) => {\n        const { ordinal, el } = out;\n        \n        // we already found \n        if(ordinal) return out;\n\n        return (el.includes(word))\n            ? ({\n                ordinal: wordValue,\n                el: el.replace(word + ' ', '')\n            })\n            : out\n    }, { el });\n}\n\n// pass a single element or chain (parent => child) as an Array\n// to get the selected Cypress element\nexport const getNormalized = (elements, { text, singular } = {}) => {\n    if (!Array.isArray(elements)) {\n        elements = [elements];\n    }\n\n    // in case it comes in from a parent optional environemnt\n    elements = elements.filter(el=>el);\n\n    // for now we apply it to the first ordinal we get\n    // ex: third Button in the second Modal will just get the third Button overall\n    let firstOrdinal;\n    let lastParentSelectors;\n    \n    let className = elements.reduce((out, elementStr, i) => {\n        let element;\n        // ex: Button's => Button\n        element = elementStr.replace('\\'s', '');\n        \n        if(singular) {\n            // Buttons => Button\n            element = pluralize.singular(element);\n        }\n\n        const {\n            ordinal, \n            el\n        } = parseNumberEls(element);\n\n        if (!firstOrdinal && ordinal) {\n            firstOrdinal = ordinal;\n        }\n    \n        let selectors = ELEMENT_SELECTORS;\n\n        // for now just supports 1 level of nest\n        if (out[i - 1]) {            \n            selectors = lastParentSelectors;\n        }\n\n        const selector = selectors[el];\n\n        if (!selector) {\n            const lastParent = elements[i - 1]\n                ? elements[i - 1] + '>'\n                : '';\n            throw new Error(`The className was not defined for ${lastParent}${el}`);\n        }\n\n        if (selector.default) {\n            lastParentSelectors = selector;\n        }\n\n        // if it's a container\n        const className = selector.default\n            ? selector.default\n            : selector;\n    \n        return [...out, className];\n    }, []).join(' ');\n\n    if (text) {\n        className += `:contains(\"${text}\")`;\n    }\n\n    const el = selectElement(className);\n\n    if(firstOrdinal) {\n        if (firstOrdinal === 'last') {\n            return el.last();\n        } else {\n            return el.eq(firstOrdinal - 1);\n        }\n    }\n    \n    return el;\n}\n\nexport const getSelector = (el) => {\n    const selector = ELEMENT_SELECTORS[el];\n\n    if (!selector) {\n        throw Error(`getSelector cannot find class for ${el}`);\n    }\n\n    const className = selector.default\n            ? selector.default\n            : selector;\n    \n    return buildClassSelector(className);\n}\n\nexport const itemShouldBeVisible = el => (\n    getNormalized(el).first().should('exist')\n);\n\nexport const clickElement = (el, parent, text) => (\n    getNormalized([parent, el], { text })\n        .first()\n        .click()\n);\n\nexport const shouldExist = (element, { parent, text }) => {\n    const els = [parent, element].filter(e=>e)\n    const el = getNormalized(els);\n\n    return text !== undefined\n        ? el.contains(text)\n        : el.should('exist');\n}\n\nexport const waitForResults = () => {\n    cy.wait(1000);\n}"]}