{"version":3,"sources":["../lib/generateAutoPhrases.js"],"names":["verbs","hex2rgbCSS","hex","red","green","blue","alpha","r","str","RegExp","or","arr","capture","noLeadingSpace","required","map","word","join","string","int","elInEl","When","clickElement","text","input","parent","type","clear","screen","url","SCREENS","Error","cy","visit","direction","windowObj","window","then","win","get","body","scrollHeight","px","scrollTo","waitForResults","Then","should","number","el","singular","shouldExist","background"],"mappings":"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","file":"generateAutoPhrases.js","sourcesContent":["import hex2rgb from 'hex-rgb';\n\nimport {\n    SCREENS\n} from './variables';\n\nimport {\n    clickElement,\n    shouldExist,\n    getNormalized,\n    waitForResults,\n} from './functions';\n\nexport const verbs = [\n    'a',\n    'on',\n    'on the',\n    'the',\n    'into',\n    'into the',\n    'of',\n    'of the',\n    'in',\n    'in the',\n    'inside',\n    'inside of',\n    'inside the',\n    'inside of the',\n    'on the',\n];\n\nexport const hex2rgbCSS = (hex) => {\n    const { red, green, blue, alpha } = hex2rgb(hex);\n\n    return `rgb(${red}, ${green}, ${blue}${alpha < 255 ? ` ${alpha}` : ''})`;\n}\n\n// regex builder (via string)\nexport const r = str => new RegExp(`^${str}$`, 'i');\n\nexport const or = (arr, { capture, noLeadingSpace, required } = {}) =>`(${\n    capture ? '' : '?:'}${\n    arr.map(\n        word => (\n            noLeadingSpace\n                ? ''\n                : ' '\n            ) + word\n    ).join('|')})${\n    required ? '' : '?'}`;\n\nexport const string = '\"([^\"]+)\"';\nexport const int = '(\\\\d+)';\n\nexport const elInEl = `${or(verbs)} ${string}(?:${or(verbs)} ${string})?(?: containing ${string})?`;\n\nexport default () => {\n    // ex:  I click on the \"Button\"\n    //      I click \"Save\"\n    //      I click on \"Save\" inside the \"Modal\"\n    //      I click on \"Button\" inside the \"Modal\" containing \"Save\"\n    When(\n        r(`I click${elInEl}`),\n        clickElement\n    );\n\n\n    // ex:  I type \"toli\" into the \"Username Input\"\n    //      I type \"toli\" into \"Username\"\n    //      I type \"toli\" into the \"Username Input\" on the \"SignIn form\"\n    When(\n        r(`I type ${string}${elInEl}`),\n        (text, input, parent) => {\n            getNormalized([parent, input]).type(text);\n        }\n    );\n\n    // ex:  When I replace the contents of \"Username\" with \"toli\"\n    //      When I replace the contents of \"Username\" inside of the \"Login Modal\" with \"toli\"\n    When(\n        r(`I replace the contents${elInEl} with ${string}`),\n        (input, parent, text) => {\n            // overload\n            if (!text) text = parent;\n\n            getNormalized([parent, input])\n                .clear()  \n                .type(text);\n        }\n    );\n\n    // ex: I open the \"Login Screen\"\n    When(\n        r(`I open${elInEl}`),\n            screen => {\n            const url = SCREENS[screen];\n            \n            if(!url) throw Error(`Screen ${screen} has no specified URL`);\n            \n            cy.visit(url); \n        }\n    );\n\n    // ex: I scroll to the bottom the \"Modal\"\n    When(\n        r(`I scroll to the (top|bottom) of the page`),\n        (direction) => {\n            let windowObj;\n            cy.window()\n                .then(win => {\n                    windowObj = win;\n                    return cy.get('body')\n                })\n                .then(body => {\n                    const { scrollHeight } = body[0];\n                    const px = direction === 'top'\n                        ? 0\n                        : scrollHeight + 100;\n\n                    // electron is stupid: https://stackoverflow.com/questions/15691569/javascript-issue-with-scrollto-in-chrome\n                    windowObj.scrollTo(0, 0);\n                });\n        }\n    );\n\n    // @TODO: Figure out while default way isn't working\n    When('I wait for results to load', waitForResults);\n\n    // ex: I should be redirected to the \"Login Screen\"\n    Then('I should be redirected to the {string}', screen => {\n        cy.url().should('contain', SCREENS[screen]);\n    });\n\n    // I should see 3 \"Buttons\" in \"Modal\"\n    Then(\n        r(`I should see ${int}${elInEl}(?: containing ${string})?`),\n        (number, el, parent, text) => {\n            getNormalized([parent, el], { singular: true, text })\n                .should('have.length', number);\n        }\n    );\n\n    // ex: I should see \"Press Me\" on the \"Button\" inside the \"Modal\"\n    Then(\n        r(`I should see ${string}${elInEl}`),\n        (text, el, parent) => shouldExist(el, { parent, text })\n    );\n\n    // putting after because the one before exclusively works \n    // for text and doesn't have a verb before it\n    // ex: I should see \"Press Me Button\" on the \"Button\" inside the \"Modal\"\n    Then(\n        r(`I should see${elInEl}`),\n        (el, parent) => shouldExist(el, { parent })\n    );\n\n    // ex:  I should not see the \"Buttons\" in the \"Modal\"\n    //      I should not see \"Buttons\" on the \"Page\"\n    //      I should not see the \"Button\"\n    Then(\n        r(`I should not see${elInEl}`),\n        (el, parent) => {\n            getNormalized([parent, el], { singular: true })\n                .should('have.length', 0);\n        }\n    );\n\n    // ex: \"Username\" should be \"toli\"\n    Then('{string} should be {string}', shouldExist);\n\n    // ex: \"Username's\" value should be \"toli\"\n    Then('{string} value should be {string}', shouldExist);\n\n    // ex: I should see a \"red\" background on the \"Button\"\n    Then(\n        r(`I should see a ${string} background${elInEl}`),\n        (background, el, parent) => {\n            getNormalized([parent, el]).should('have.css', 'background-color', hex2rgbCSS(background))\n        }\n    )\n\n     // ex: I should see a \"red\" border on the \"Button\"\n     Then(\n        r(`I should see a ${string} border${elInEl}`),\n        (background, el, parent) => {\n            getNormalized([parent, el]).should('have.css', 'border-color', hex2rgbCSS(background))\n        }\n    )\n}\n"]}