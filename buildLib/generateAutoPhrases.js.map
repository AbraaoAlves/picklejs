{"version":3,"sources":["../lib/generateAutoPhrases.js"],"names":["verbs","r","str","RegExp","or","arr","capture","noLeadingSpace","required","map","word","join","string","int","elInEl","When","clickElement","text","input","parent","replace","Math","round","random","type","clear","screen","url","SCREENS","Error","cy","visit","el","windowObj","window","then","win","get","body","scrollHeight","scrollTo","waitForResults","Then","should","number","singular","shouldExist"],"mappings":"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","file":"generateAutoPhrases.js","sourcesContent":["import {\n    SCREENS\n} from './variables';\n\nimport {\n    clickElement,\n    shouldExist,\n    getNormalized,\n    waitForResults,\n} from './functions';\n\nexport const verbs = [\n    'a',\n    'on',\n    'on the',\n    'the',\n    'into',\n    'into the',\n    'of',\n    'of the',\n    'in',\n    'in the',\n    'inside',\n    'inside of',\n    'inside the',\n    'inside of the',\n    'on the',\n];\n\n// regex builder (via string)\nexport const r = str => new RegExp(str, 'i');\n\nexport const or = (arr, { capture, noLeadingSpace, required } = {}) =>`(${\n    capture ? '' : '?:'}${\n    arr.map(\n        word => (\n            noLeadingSpace\n                ? ''\n                : ' '\n            ) + word\n    ).join('|')})${\n    required ? '' : '?'}`;\n\nexport const string = '\"([^\"]+)\"';\nexport const int = '(\\\\d+)';\n\nexport const elInEl = `${or(verbs)} ${string}(?:${or(verbs)} ${string})?`;\n\nexport default () => {\n    // ex:  I click on the \"Button\"\n    //      I click \"Save\"\n    //      I click on \"Save\" inside the \"Modal\"\n    When(\n        r(`I click${elInEl}`),\n        clickElement\n    );\n\n\n    // ex:  I type \"toli\" into the \"Username Input\"\n    //      I type \"toli\" into \"Username\"\n    //      I type \"toli\" into the \"Username Input\" on the \"SignIn form\"\n    When(\n        r(`I type ${string}${elInEl}`),\n        (text, input, parent) => {\n            text = text.replace('<rand>', Math.round(Math.random() * 10000))\n            getNormalized([parent, input]).type(text);\n        }\n    );\n\n    // ex:  When I replace the contents of \"Username\" with \"toli\"\n    //      When I replace the contents of \"Username\" inside of the \"Login Modal\" with \"toli\"\n    When(\n        r(`I replace the contents${elInEl} with ${string}`),\n        (input, parent, text) => {\n            // overload\n            if (!text) text = parent;\n\n            getNormalized([parent, input])\n                .clear()  \n                .type(text);\n        }\n    );\n\n    // ex: I open the \"Login Screen\"\n    When(\n        r(`I open${elInEl}`),\n            screen => {\n            const url = SCREENS[screen];\n            \n            if(!url) throw Error(`Screen ${screen} has no specified URL`);\n            \n            cy.visit(url); \n        }\n    );\n\n    // ex: I scroll to the bottom the \"Modal\"\n    When('I scroll to the bottom of the {string}', (el) => {\n        let windowObj;\n        cy.window()\n            .then(win => {\n                windowObj = win;\n                return cy.get('body')\n            })\n            .then(body => {\n                const { scrollHeight} = body[0];\n                windowObj.scrollTo(0, scrollHeight + 100);\n            });        \n    });\n\n    // @TODO: Figure out while default way isn't working\n    When('I wait for results to load', waitForResults);\n\n    // ex: I should be redirected to the \"Login Screen\"\n    Then('I should be redirected to the {string}', screen => {\n        cy.url().should('contain', SCREENS[screen]);\n    });\n\n    // I should see 3 \"Buttons\" in \"Modal\"\n    Then(\n        r(`I should see ${int}${elInEl}(?: containing ${string})?`),\n        (number, el, parent, text) => {\n            getNormalized([parent, el], { singular: true, text })\n                .should('have.length', number);\n        }\n    );\n\n    // ex: I should see \"Press Me\" on the \"Button\" inside the \"Modal\"\n    Then(\n        r(`I should see ${string}${elInEl}`),\n        (text, el, parent) => shouldExist(el, { parent, text })\n    );\n\n    // putting after because the one before exclusively works \n    // for text and doesn't have a verb before it\n    // ex: I should see \"Press Me Button\" on the \"Button\" inside the \"Modal\"\n    Then(\n        r(`I should see${elInEl}`),\n        (el, parent) => shouldExist(el, { parent })\n    );\n\n    // ex:  I should not see the \"Buttons\" in the \"Modal\"\n    //      I should not see \"Buttons\" on the \"Page\"\n    //      I should not see the \"Button\"\n    Then(\n        r(`I should not see${elInEl}`),\n        (el, parent) => {\n            getNormalized([parent, el], { singular: true })\n                .should('have.length', 0);\n        }\n    );\n\n    // ex: \"Username\" should be \"toli\"\n    Then('{string} should be {string}', shouldExist);\n\n    // ex: \"Username's\" value should be \"toli\"\n    Then('{string} value should be {string}', shouldExist);\n}\n"]}